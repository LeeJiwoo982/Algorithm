# List 1 | 1차원배열
## 1차원 배열 입력
### 공백을 두고 입력
`arr = list(map(int, input().split()))`
## 정렬 = 크기 순으로 재배열
- 오름차순(ascending): 작은 값>큰 값
- 내림차순(descending): 반대
### Bubble Sort
인접한 두 개의 원소를 비교하여 자리를 계속 교환
- O(N^2)
#### 버블 정렬 과정
- 첫 번째 원소부터 인접 원소와 비교 후 교환
- 맨마지막 자리까지 이동
- 한 단계(1 pass) 끝나면 가장 큰 원소가 마지막 자리로
- (N-1)단계 후에 최종 정렬 완성
- 1pass 지나면 가장 끝 원소가 최댓값
> 1pass => 1개의 원소 정렬
- 첫 순회는 큰 수부터, 두번째 순회는 첫순회의 변수를 범위로
### Counting Sort
순서 결정을 위해 각 항목이 몇 개씩 있는지 세는(count) 작업으로
선형 시간에 정렬
- O(N+k) : N은 리스트 길이, k 정수의 최댓값
- 정수 표현 자료에만 적용 가능
- 각 항목의 발생 횟수 기록, 인덱스로 사용가능해야
- 카운트를 위한 공간을 위해 항목에서 가장 큰 항목을 알아야 한다.
- K: 최댓값의 크기 중요
#### 1단계 카운팅
data 각 항목의 발생을 카운트배열의 인덱스를 통해 +1 저장
`cnt[i]=> i의 발생 횟수`
#### 2단계 누적
cnt의 원소를 누적시킨다
#### 3단계 정렬
1. data의 마지막 요소(=j)부터 정렬 시작 > 처음 데이
   터 인덱스 순을 최대한 보존해줌. 메모리주소 보면 알게 됨
2. cnt[data[j]] -= 1 한 값을 temp[cnt[data[j]]] += 1로 
3. 누적된 값이 위치정보가 되고, 그걸 정렬해주기 전 -1한 값이 그 최종 위치가 된다.
### Selection Sort