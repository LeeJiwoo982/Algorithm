# List 1 | 1차원배열
## 1차원 배열 입력
### 공백을 두고 입력
`arr = list(map(int, input().split()))`
## 정렬 = 크기 순으로 재배열
- 오름차순(ascending): 작은 값>큰 값
- 내림차순(descending): 반대

|알고리즘|평균 수행시간| 최악 수행  | 알고리즘 기법 |비고|
|-------|-----------|--------|---------|----|
|버블|O(n^2)| same   | 비교&교환   | 제일 쉽다              |
|카운팅|O(n+k)| same   | 비교환 방식  | n이 비교적 작을 때 사용, 정수 |
|선택|O(n^2)| same   | 비교&교환   | 교환의 횟수 버블, 삽입보다 적음 |
|퀵|O(n log n)| O(n^2) |분할 정복|최악이 있지만, 평균적으로 가장 빠름|
|삽입|O(n^2)|same|비교&교환|n의 개수가 작을 때 효과적|
|병합|O(n log n)|same|분할 정복|연결리스트의 경우 가장 효율적|
### **Bubble Sort**
인접한 두 개의 원소를 비교하여 자리를 계속 교환
- O(N^2)
#### 버블 정렬 과정
- 첫 번째 원소부터 인접 원소와 비교 후 교환
- 맨마지막 자리까지 이동
- 한 단계(1 pass) 끝나면 가장 큰 원소가 마지막 자리로
- (N-1)단계 후에 최종 정렬 완성
- 1pass 지나면 가장 끝 원소가 최댓값
> 1pass => 1개의 원소 정렬
- 첫 순회는 큰 수부터, 두번째 순회는 첫순회의 변수를 범위로
### **Counting Sort**
순서 결정을 위해 각 항목이 몇 개씩 있는지 세는(count) 작업으로
선형 시간에 정렬
- O(N+k) : N은 리스트 길이, k 정수의 최댓값
- 정수 표현 자료에만 적용 가능
- 각 항목의 발생 횟수 기록, 인덱스로 사용가능해야
- 카운트를 위한 공간을 위해 항목에서 가장 큰 항목을 알아야 한다.
- K: 최댓값의 크기 중요
#### 1단계 카운팅
data 각 항목의 발생을 카운트배열의 인덱스를 통해 +1 저장
`cnt[i]=> i의 발생 횟수`
#### 2단계 누적
cnt의 원소를 누적시킨다
#### 3단계 정렬
1. data의 마지막 요소(=j)부터 정렬 시작 > 처음 데이
   터 인덱스 순을 최대한 보존해줌. 메모리주소 보면 알게 됨
2. cnt[data[j]] -= 1 한 값을 temp[cnt[data[j]]] += 1로 
3. 누적된 값이 위치정보가 되고, 그걸 정렬해주기 전 -1한 값이 그 최종 위치가 된다.
### 완전 검색
모든 경우의 수를 나열해보고 확인
- Brute-Force or Generate-and-test 기법이라고도
### 순열 Permutation
서로 다른 n개 중 r개를 택해서 한 줄로 나열(순서있음?)
nPr = n*(n-1)*(n-2)*...*(n-r+1) = 
nPn = n! = Factorial
### 탐욕 Greedy Algorithm
최적해를 구하는 **근시안적** 방법
- 순간에 최적이라 생각되는 것을 선택해 나가는 방식은 최종결과가 최적이 되지 않음
### Selection Sort
제자리 정렬 중 하나>> 입력값 외에 추가 메모리를 요구하지 않음
#### 선택정렬 과정
1. 입력 배열의 최솟값을 구한다.
2. 맨 앞에 위치한 값과 교체 (1pass)
3. 맨 처음 위치를 제외한 나머리 리스트에서 같은 방법으로 교체
4. 