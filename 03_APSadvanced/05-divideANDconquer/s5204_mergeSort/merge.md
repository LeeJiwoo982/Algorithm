# 병합 정렬
##### 핵심 아이디어 
##### : 정렬되어 있는 두 개의 배열을 합쳐서
##### 정렬된 배열을 만드는 것은 쉽다(= 빠르다)

```python
N = 10
L = [2, 5, 6, 7, 8]
R = [1, 2, 6, 8, 9]

arr = [0]*(N+1)

# merge 과정
i = j = k = 0
__
# i와 j를 비교하려면 둘 다 각자의 배열의 인덱스 범위 안에 있어야 비교가 가능하다
while i < len(L) and j < len(R):
    if L[i] <= R[j]:    #왼쪽 배열의 수가 더 작거나 같다면
        arr[k] = L[i]
        k += 1
        i += 1
    else:   #오른쪽 배열의 수가 더 작다면
        arr[k] = R[j]
        k += 1
        j += 1

# while문이 끝나면
# 둘 중 배열 하나는 i, j 가 볌위를 넘음
# L, R 둘 중 하나는 이미 소진 <=> 둘 중 하나는 아직 배열에 값이 남아있음
#       >> 나머지 값은 그냥 순서대로 arr 배열에 옮기면 됨

while i < len(L):
    arr[k] = L[i]
    k += 1
    i += 1

while j < len(R):
    arr[k] = R[j]
    k += 1
    j += 1
```

k = 다음 인덱스
pivot = 
i = L의 제일 왼쪽
j = R의 제일 왼쪽에서 시작

# 병합하기 로직
i, j, k를 0으로 놓고 출발
i: L배열의 가장 작은 원소를 가리키는 포인터
j : R배열의 가장 작은 원소를 가리키는 포인터
k : 합친 배열의 원소를 가리키는 포인터

i, j번째를 비교해서 둘중 작은 값을 k번째에 적는다.
i번째 수가 더 작다면: i번째 수를 arr배열에 쓰고, i += 1, k += 1
j번째 수가 더 작다면: j번째 수를 arr배열에 쓰고, j += 1, k += 1

>> 선형시간 안에 정렬 가능 O(N)


### 쪼갤 때는 큰 것 -> 작은 것 순으로 쪼개짐   (8, 4, 2, 1)
### 합칠 때는 길이가 1인 것부터                (1, 2, 4, 8)